library(devtools)
use_mit_license("Abdul-Nasah Soale")
use_readme_rmd()
build_readme()
n0 <- 48   ## number of uncontaminated observations
inf.obs <- 2   ## number of outliers
## generate X and Y
X0 <- LaplacesDemon::rmvn(n0, rep(0,p), Sig)
X0 <- LaplacesDemon::rmvn(n0, rep(0,p), Sig)
## generate X and Y
X0 <- LaplacesDemon::rmvn(n0, rep(0,p), diag(p))
p <- 5 ## number of predictors
X0 <- LaplacesDemon::rmvn(n0, rep(0,p), diag(p))
eps <- rnorm(n0,0,1)
Y0 <- 0.5 + (X0%*%beta) + 0.8*eps
beta <- c(-2, 0, 0.5, 1.5, 0)
Y0 <- 0.5 + (X0%*%beta) + 0.8*eps
dat0 <- data.frame(X=X0,Y=Y0)
Sig <- 0.5^abs(outer(1:p,1:p,"-"))
X0 <- LaplacesDemon::rmvn(n0, rep(0,p), Sig)
eps <- rnorm(n0,0,1)
Y0 <- 0.5 + (X0%*%beta) + 0.8*eps
dat0 <- data.frame(X=X0,Y=Y0)
##leverage only contamination
X1 <- LaplacesDemon::rmvt(inf.obs, rep(5,p), Sig, df=10)
Y1 <- 0.5 + (X1%*%beta) + 0.8*rnorm(inf.obs)
dat1 <- data.frame(X=X1,Y=Y1)
## combine the contaminated and uncontaminated data
dat <- rbind(dat0, dat1)
dat <- dat[sample(1:n),]   ## mix the samples up -- but not necessary
n <- 50
dat <- dat[sample(1:n),]   ## mix the samples up -- but not necessary
X <- as.matrix(dat[, 1:p])
Y <- dat$Y
## Apply SOPG-LAD
contr <- 0.05    ## set contribution threshold
contr <- 0.05    ## set contribution threshold
lambda <- 0.01    ## should be between 0 and 1
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
sopg_lad <- function(X,Y, lambda=0.01, M=NULL, tol=0.005, lambda.cv=FALSE){
if(!is.matrix(X)) X <- as.matrix(X)
X <- scale(X)
n <- dim(X)[1]
p <- dim(X)[2]
## Compute kernel
D <- as.matrix(dist(X, method="euclidean"))
Kn <- kern(D)
W <- Kn$K
## Find local gradient directions from weighted penalized regression
Betas <- lapply(1:n, function(i){
xi <- sqrt(W[i,])*t(t(X)-X[i,])
yi <- sqrt(W[i,])*Y
if(lambda.cv==TRUE){
fit2 = conquer.cv.reg(xi, yi, tau=0.5, penalty="lasso")
B.cv = fit2$coeff.min[-1]
} else {
fit2 = conquer.reg(xi, yi, lambda=lambda, tau=0.5, penalty="lasso")
B.cv = fit2$coeff[-1]
}
return(B.cv)
})
BB <- do.call(rbind, Betas)
# perform space SVD on gradients
if(!is.null(M)) {
G <- ssvd(BB, k=1, n=M)
B.slg <- G$v
} else{
p0 <- 1
delta <- 1
G0 <- ssvd(BB, k=1, n=1)
d0 <- as.vector(G0$d)
n0 <- 1
while(TRUE){
if((delta > tol) & (p0 < p)) {
n0 <- n0 + 1
G <- ssvd(BB, k=1, n=n0)
d1 <- as.vector(G$d)
delta <- (d1-d0)/d0
p0 <- sum((G$v != 0))
d0 <- d1
} else{
break
}
}
n1 <- n0-1
G <- ssvd(BB, k=1, n=n1)
B.slg <- G$v
}
return(B.slg)
}
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
## Gaussian kernel function
kern <- function(D){
n <- dim(D)[1]
Dupper <- D[upper.tri(D,diag = FALSE)]
sigma2 <- sum(Dupper^2)/choose(n,2)
gamma <- 1/(2*sigma2)
return(list(gamma=gamma, K=exp(-gamma*D)))
}
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
require(conquer)
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
require(irlba)
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
B.sopg_lad
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=3, tol=contr, lambda.cv=FALSE)
B.sopg_lad
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=4, tol=contr, lambda.cv=FALSE)
B.sopg_lad
contr <- 0.05    ## set contribution threshold
lambda <- 0.001    ## should be between 0 and 1
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
B.sopg_lad
contr <- 0.05    ## set contribution threshold
lambda <- 0.1    ## should be between 0 and 1
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
B.sopg_lad
contr <- 0.01    ## set contribution threshold
lambda <- 0.1    ## should be between 0 and 1
B.sopg_lad <- sopg_lad(X,Y,lambda=lambda, M=NULL, tol=contr, lambda.cv=FALSE)
B.sopg_lad
summary(cars)
document()
build_rmd()
build_rmd(
)
use_testthat()
testthat::test_that("sopg_lad")
devtools::load_all(".")
